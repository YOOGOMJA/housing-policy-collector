# 아키텍처

## 모듈 경계 (문서 ↔ 코드 1:1 매핑)

아래 명칭은 문서와 실제 패키지/디렉터리를 1:1로 고정합니다.

| 문서 모듈명 | 실제 패키지/디렉터리 | 책임 |
|---|---|---|
| Collector | `src/collector` | 공고 원문/목록 수집 |
| Parser | `src/parser` | 원문 정규화 및 구조화 |
| Matcher | `src/matcher` | 사용자 조건 기반 매칭 |
| Notifier | `src/notifier` | 채널별 알림 전송 |
| Storage | `src/storage` | 영속 저장 및 조회 |

## 실행 진입점 분리

| 구분 | 실행 진입점 | 비고 |
|---|---|---|
| 앱 런타임 | `src/main.ts` | 실시간/일반 실행 진입점 |
| 배치 런타임 | `src/batch_main.ts` | 스케줄/수동 배치 실행 진입점 |

- 개발 실행: `npm run dev` 또는 배치 기준 `npm run dev:batch`
- 운영 실행: `tsc` 빌드 후 `npm run start`, `npm run start:batch`

## Storage 전략: 로컬 DB 영속성 vs Supabase

### 1) 결론(권장안)
- 현재 단계의 우선 전략은 **로컬 SQLite 영속 운영**입니다.
- 단, 사용자 수/알림량 증가로 운영 부담이 커지면 **Supabase(Managed Postgres)로 단계적 전환**합니다.

### 2) 선택 기준 요약
| 항목 | 로컬 DB 영속성 (예: SQLite/Postgres on VM) | Supabase (Managed Postgres) |
|---|---|---|
| 장애 복구 | 사용자가 직접 백업/복구 설계 필요 | 백업/복구, 고가용성 옵션 활용 용이 |
| 운영 난이도 | 인프라/스토리지/모니터링 직접 관리 | DB 운영 부담이 상대적으로 낮음 |
| 비용 | 소규모에서는 매우 저렴 | 사용량 증가 시 과금 상승 가능 |
| 확장성 | 수동 확장/마이그레이션 필요 | Postgres 기반 확장, 외부 연동 용이 |
| 보안/접근제어 | 서버 보안 책임이 전적으로 사용자에게 있음 | RLS, 키 관리 등 기본 기능 활용 가능 |
| 락인(lock-in) | 낮음 | 중간 (Postgres 자체는 이식 가능) |

### 3) 이 프로젝트 기준 판단 근거
- 현재는 1인 운영/저트래픽 전제로, 빠른 개발과 단순 운영이 중요합니다.
- 데이터 모델은 관계형 DB 적합도가 높아, **SQLite로 시작 후 Postgres로 이행 가능한 스키마 설계**가 유효합니다.
- 운영 복잡도가 임계점을 넘는 시점(배치 실패 대응 시간 증가, 동시성 이슈, 백업/복구 부담 증가)부터 Managed Postgres 전환이 유리합니다.

### 4) 권장 아키텍처 패턴
1. 애플리케이션 런타임은 stateless하게 유지
2. 영속 데이터는 SQLite 파일(영속 볼륨)로 저장
3. 민감정보는 컬럼 단위 암호화 + 최소수집
4. 배치 실행 이력/실패 로그 테이블을 분리해 장애 분석 가능하게 설계

### 5) 로컬 DB(SQLite) 운영 최소 안전장치
- DB 파일/볼륨을 컨테이너 외부 영속 볼륨에 저장
- 일 단위 스냅샷 백업 + 주 단위 복구 리허설
- 장애 시 재처리를 위한 idempotency 키(공고 source_id 등) 적용
- 로그에는 개인정보 원문을 남기지 않음

### 6) Supabase 전환 트리거(권장 기준)
- 단일 노드 SQLite에서 write contention이 반복 발생
- 알림/배치 작업이 증가해 복구시간 목표(RTO) 충족이 어려움
- 수동 백업/복구 운영비용이 월 고정비보다 커지는 시점

### 7) 단계별 도입 제안
- **MVP~초기 운영**: 로컬 SQLite + 백업 자동화 + 복구 리허설
- **전환 준비**: Postgres 호환 스키마/마이그레이션 스크립트 상시 유지
- **확장 운영**: Supabase 전환 후 모니터링/SLA 기준으로 튜닝
